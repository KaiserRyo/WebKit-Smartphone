#!/usr/bin/env perl
# Copyright (C) Research in Motion Limited 2010. All rights reserved.
#
# Update script for the Athens project.

use warnings;
use strict;
use File::Basename;
use FindBin;
use lib $FindBin::Bin;
use Getopt::Long;
use olympiadirs;
use olympiascm;

my $onlyUpdateCurrentWorkingRepo; # By default, we update all repositories.
my $quiet;
my $rollbackLastUpdate;
my $shouldRebase = 1; # By default, we rebase.
my $shouldSaveSHAs = 1; # By default, we save the last fetched SHAs.
my $showHelp;

sub arrayContains($$);
sub checkForNewOlympiaBranchStep($);
sub gitFetchStep($);
sub gitPrintOnlyFileChangesAndErrors($);
sub gitRebaseStep($);
sub gitRestoreChanges($);
sub gitStashChangesIfNeeded($);
sub hasNewGitCheckout;
sub isNewOlympiaBranchAvailable;
sub parseLastFetchedSHAs;
sub preUpdateStep($);
sub postUpdateStep($);
sub restoreLastFetchedSHAsStep($);
sub runSteps;
sub saveLastFetchedSHAsIfNeededStep($);
sub writeMessageToFile($$);

$| = 1; # Disable output buffering so that we print to the screen as soon as possible.

my $getOptionsResults = GetOptions(
    'h|help' => \$showHelp,
    'q|quiet' => \$quiet,
    'single' => \$onlyUpdateCurrentWorkingRepo,
    'rollback-to-last-update' => \$rollbackLastUpdate,
    'rebase!' => \$shouldRebase,
    'save!' => \$shouldSaveSHAs,
);

if (!$getOptionsResults || $showHelp) {
    print STDERR <<__END__;
Usage: @{[ basename($0) ]} [options]
  -h|--help                    show the help message
  -q|--quiet                   quiet updates
  --single                     only update the current working repository
  --rollback-to-last-update    rollback the last update
  --[no-]rebase                Toggle applying the downloaded changes to the working copy
  --[no-]save                  Toggle saving of the last fetched SHAs
__END__
    exit(1);
}

my %state; # Shared state store for steps.
$state{LastFetchedSHAsFile} = sourceDir() . "/LastFetchedSHAs";
$state{UpdateFailedFile} = sourceDir() . "/update.failed";

if ($onlyUpdateCurrentWorkingRepo) {
    my $repoPath = determineRepoDir();
    $state{Repositories} = [substr($repoPath, rindex($repoPath, "/") + 1)]; # The name of the repository to update.
    $state{OnlyUpdateCurrentWorkingRepo} = 1;
} else {
    $state{Repositories} = [repositories()];
}

my @steps = (\&preRequisiteStep);
if ($rollbackLastUpdate) {
    push @steps, \&restoreLastFetchedSHAsStep;
    push @steps, \&postUpdateStep;
} else {
    push @steps, \&preUpdateStep;
    push @steps, \&saveLastFetchedSHAsIfNeededStep if $shouldSaveSHAs;
    push @steps, \&gitFetchStep;
    push @steps, \&gitRebaseStep if $shouldRebase;
    push @steps, \&checkForNewOlympiaBranchStep;
    push @steps, \&postUpdateStep;
}
runSteps(\@steps, \%state);

###
# Steps.
##

sub preRequisiteStep
{
    dieIfRequiredRepositoriesAreMissing();
    chdirAthens();
}

sub preUpdateStep($)
{
    my ($state) = @_;
    print "Updating Athens\n" unless $quiet;
}

sub postUpdateStep($)
{
    my ($state) = @_;
    unlink $state->{UpdateFailedFile} if -e $state->{UpdateFailedFile};
    # FIXME: We should re-source the build-olympia-tools.env file.
    print "\nPlease start a new terminal window before building!\n" unless $quiet;
}

sub saveLastFetchedSHAsIfNeededStep($)
{
    my ($state) = @_;
    if (-e $state->{UpdateFailedFile} || hasNewGitCheckout()) {
        # We do not save the last fetched SHAS if we previously failed (i.e. exists file $state->{UpdateFailedFile})
        # since we may have partially fetch/rebased and saving the SHAs could reflect these  "partial" commits.
        return;
    }

    print "Saving the SHAs from the last Git fetch\n" unless $quiet;
    my @shas;
    my $callback = sub {
        my $directoryName = shift;
        my %pair;
        $pair{DirectoryName} = $directoryName;
        $pair{SHA} = gitLastFetchedSHA(gitRemoteBranch());
        push @shas, \%pair;
    };
    processDirectories([repositories()], $callback);

    open(OUTPUT, ">$state->{LastFetchedSHAsFile}") or die "Failed to write to file '$state->{LastFetchedSHAsFile}': $!.";
    print OUTPUT "$_->{DirectoryName}: $_->{SHA}\n" foreach (@shas);
    close(OUTPUT);
}

sub restoreLastFetchedSHAsStep($)
{
    my ($state) = @_;
    open(INPUT, $state->{LastFetchedSHAsFile}) or die "Cannot open file '$state->{LastFetchedSHAsFile}': $!.";
    my $shas = parseLastFetchedSHAs(\*INPUT);
    close(INPUT);

    my $savedCwd = getcwd();
    foreach my $pair (@$shas) {
        chdir(sourceDir() . "/$pair->{DirectoryName}");
        my $didStashChanges;
        if (gitStashChangesIfNeeded($pair->{DirectoryName})) {
            $didStashChanges = 1;
            print "Resetting '$pair->{DirectoryName}' to $pair->{SHA}.\n" unless $quiet;
        }
        gitReset(GitResetMerge, $pair->{SHA});
        gitRestoreChanges($pair->{DirectoryName}) if $didStashChanges;
    }
    chdir($savedCwd);

    # We write an update failed file so that if the next update-athens does not produce a good build
    # we can always fall back on the known working SHAs in LastFetchedSHAs.
    writeMessageToFile($state->{UpdateFailedFile}, "reverted to last fetched SHAs");
}

sub gitFetchStep($)
{
    my ($state) = @_;
    print "Fetching changes... This can take up to 30 minutes or longer if you haven't updated recently.\n" unless $quiet;
    my $callback = sub {
        my $directoryName = shift;
        my $remoteBranch = gitRemoteBranch();
        print "Fetching changes for '$directoryName'.\n" if !$quiet && $state->{OnlyUpdateCurrentWorkingRepo};
        writeMessageToFile($state->{UpdateFailedFile}, $directoryName);
        gitFetch(substr($remoteBranch, 0, index($remoteBranch, "/")));
    };
    processDirectories($state->{Repositories}, $callback);
}

sub gitRebaseStep($)
{
    my ($state) = @_;
    my $callback = sub {
        my $directoryName = shift;
        my $didStashChanges;
        $didStashChanges = 1 if gitStashChangesIfNeeded($directoryName);
        print "Rebasing '$directoryName'.\n" if !$quiet && ($didStashChanges || $state->{OnlyUpdateCurrentWorkingRepo});
        writeMessageToFile($state->{UpdateFailedFile}, $directoryName);
        gitRebase(gitRemoteBranch(), \&gitPrintOnlyFileChangesAndErrors);
        gitRestoreChanges($directoryName) if $didStashChanges;
    };
    processDirectories($state->{Repositories}, $callback);
}

sub checkForNewOlympiaBranchStep($)
{
    my ($state) = @_;
    my $newVersionBranch = isNewOlympiaBranchAvailable();
    if ($newVersionBranch) {
        my $localBranchName = $newVersionBranch;
        $localBranchName =~ s|upstream/||;
        print "*************************************************************\n";
        print "A new branch for Olympia is available!\n";
        print "\n";
        print "Please migrate your local changes over to the branch $newVersionBranch.\n";
        print "To checkout the new branch do: 'git checkout -b $localBranchName $newVersionBranch'.\n";
        print "See the TurboStart wiki page <http://md-athens-01.swlab.rim.net/olympia/\n";
        print "pages/TurboStart> for more details.\n";
        print "*************************************************************\n";
        die;
    }
}

###
# Helper routines.
##

sub runSteps
{
    my ($steps, $state) = @_;
    &$_($state) foreach (@$steps);
}

sub arrayContains($$)
{
    my ($value, $array) = @_;
    foreach (@$array) {
        if ($_ eq $value) {
            return 1;
        }
    }
}

sub parseLastFetchedSHAs
{
    my ($fileHandle) = @_;
    my @directories = repositories();
    my @shas;
    while (<$fileHandle>) {
        # Strip off any end-of-line characters to simplify regex matching below.
        s/([\n\r]+)$//;
        if (/^(?<directoryName>\w+): (?<sha>[a-fA-F0-9]+)$/) {
            my %pair;
            $pair{DirectoryName} = $+{directoryName};
            $pair{SHA} = $+{sha};
            push @shas, \%pair if arrayContains($+{directoryName}, \@directories);
        }
    }
    return \@shas;
}

sub writeMessageToFile($$)
{
    my ($file, $message) = @_;
    open(FILE, ">$file");
    print FILE $message;
    close(FILE);
}

sub hasNewGitCheckout
{
    my $result;
    my $callback = sub { $result = isNewGitCheckout() if !$result; };
    processDirectories([repositories()], $callback);
    return $result;
}

sub gitStashChangesIfNeeded($)
{
    my ($directoryName) = @_;

    if (isGitWorkingDirectoryClean()) {
        return;
    }

    print "Stashing non-committed changes made in '$directoryName'.\n" unless $quiet;
    gitPushStash();
    return 1;
}

sub gitRestoreChanges($)
{
    my ($directoryName) = @_;

    print "Restoring non-committed changes made in '$directoryName'.\n" unless $quiet;
    gitPopStash();
}

sub gitPrintOnlyFileChangesAndErrors($)
{
    my ($_) = @_;

    # Git prints out various status and statistic messages that clutter the output.
    # We are interested in only printing the list of changed files (and any Git error messages).

    if (/^First, rewinding head to replay your work on top of it...$/){
        return;
    }

    if (/^Fast-forwarded/) {
        return;
    }

    if (/^Current branch/) {
        return;
    }

    if (/\d+ files changed, \d+ insertions\(\+\), \d+ deletions\(\-\)$/) {
        return;
    }

    print "$_\n";
}

sub isNewOlympiaBranchAvailable
{
    my $savedCwd = getcwd();
    chdir(olympiaDir());
    my $currentVersion = (gitRemoteBranch() =~ m|^upstream/master_([0-9]+)$|) ? int($1) : 0;
    if (!$currentVersion) {
        chdir($savedCwd);
        return 0;
    }
    my $isNewVersionAvailable;
    my @branches = gitRemoteBranches();
    foreach (@branches) {
        if (m|^upstream/master_([0-9]+)$|) {
            if ($currentVersion < int($1)) {
                $isNewVersionAvailable = $_;
                last;
            }
        }
    }
    chdir($savedCwd);
    return $isNewVersionAvailable;
}
